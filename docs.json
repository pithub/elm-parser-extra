[{"name":"Parser.Advanced.Extra","comment":" Convenience functions for\n[`Parser.Advanced`](https://package.elm-lang.org/packages/elm/parser/latest/Parser-Advanced).\n\n---\n\n**Everything here works just like in the\n[`Parser.Extra`](Parser-Extra) module, except that `String`\narguments become `Token` arguments, and you need to provide a `Problem` for\ncertain scenarios.**\n\n---\n\n\n## Table of Contents\n\n  - [Look Ahead](#look-ahead)\n  - [Miscellaneous](#miscellaneous)\n  - [Binds](#binds)\n  - [Low-Level](#low-level)\n\n\n# Look Ahead\n\n@docs lookAhead, negativeLookAhead\n\n\n# Miscellaneous\n\n@docs followedBy, committed\n\n\n# Binds\n\nFlipped versions of [`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser-Advanced#andThen)\nwith 1 to 5 parsers and callbacks with 1 to 5 input parameters.\n\n(In other functional languages, the flipped\nversion of `andThen` is often called \"bind\",\nhence the names here.)\n\n@docs bind, bind2, bind3, bind4, bind5\n\n\n# Low-Level\n\nThese are low-level functions which are used under the hood to implement\nsome of the other parsers of this module.\n\nMaybe they can be useful to you, too?\n\n@docs ParserResult, getParserResult, getParserOutcome\n\n","unions":[],"aliases":[{"name":"ParserResult","comment":" Result of [`Parser.Advanced.run`](https://package.elm-lang.org/packages/elm/parser/latest/Parser.Advanced#run).\nThe type alias simplifies the following function signatures a little bit.\n","args":["c","x","a"],"type":"Result.Result (List.List (Parser.Advanced.DeadEnd c x)) a"}],"values":[{"name":"bind","comment":" Just like [`Parser.Extra.bind`](Parser-Extra#bind).\n","type":"Parser.Advanced.Parser c x a -> (a -> Parser.Advanced.Parser c x b) -> Parser.Advanced.Parser c x b"},{"name":"bind2","comment":" Just like [`Parser.Extra.bind2`](Parser-Extra#bind2).\n","type":"Parser.Advanced.Parser c x a1 -> Parser.Advanced.Parser c x a2 -> (a1 -> a2 -> Parser.Advanced.Parser c x b) -> Parser.Advanced.Parser c x b"},{"name":"bind3","comment":" Just like [`Parser.Extra.bind3`](Parser-Extra#bind3).\n","type":"Parser.Advanced.Parser c x a1 -> Parser.Advanced.Parser c x a2 -> Parser.Advanced.Parser c x a3 -> (a1 -> a2 -> a3 -> Parser.Advanced.Parser c x b) -> Parser.Advanced.Parser c x b"},{"name":"bind4","comment":" Just like [`Parser.Extra.bind4`](Parser-Extra#bind4).\n","type":"Parser.Advanced.Parser c x a1 -> Parser.Advanced.Parser c x a2 -> Parser.Advanced.Parser c x a3 -> Parser.Advanced.Parser c x a4 -> (a1 -> a2 -> a3 -> a4 -> Parser.Advanced.Parser c x b) -> Parser.Advanced.Parser c x b"},{"name":"bind5","comment":" Just like [`Parser.Extra.bind5`](Parser-Extra#bind5).\n","type":"Parser.Advanced.Parser c x a1 -> Parser.Advanced.Parser c x a2 -> Parser.Advanced.Parser c x a3 -> Parser.Advanced.Parser c x a4 -> Parser.Advanced.Parser c x a5 -> (a1 -> a2 -> a3 -> a4 -> a5 -> Parser.Advanced.Parser c x b) -> Parser.Advanced.Parser c x b"},{"name":"committed","comment":" Just like [`Parser.Extra.committed`](Parser-Extra#committed).\n","type":"Parser.Advanced.Parser c x a -> Parser.Advanced.Parser c x a"},{"name":"followedBy","comment":" Just like [`Parser.Extra.followedBy`](Parser-Extra#followedBy).\n","type":"Parser.Advanced.Parser c x b -> Parser.Advanced.Parser c x a -> Parser.Advanced.Parser c x b"},{"name":"getParserOutcome","comment":" Just like [`Parser.Extra.getParserOutcome`](Parser-Extra#getParserOutcome).\n","type":"Parser.Advanced.Parser c x a -> Parser.Advanced.Parser c x ( String.String, Parser.Advanced.Extra.ParserResult c x ( a, Basics.Int ) )"},{"name":"getParserResult","comment":" Just like [`Parser.Extra.getParserResult`](Parser-Extra#getParserResult).\n","type":"Parser.Advanced.Parser c x a -> Parser.Advanced.Parser c x (Parser.Advanced.Extra.ParserResult c x a)"},{"name":"lookAhead","comment":" Just like [`Parser.Extra.lookAhead`](Parser-Extra#lookAhead).\n","type":"Parser.Advanced.Parser c x a -> Parser.Advanced.Parser c x a"},{"name":"negativeLookAhead","comment":" Just like [`Parser.Extra.negativeLookAhead`](Parser-Extra#negativeLookAhead)\nexcept you provide a `Token` instead of a `String`.\nThat way you can specify your custom type of problem\nfor when the given parser would succeed.\n","type":"x -> Parser.Advanced.Parser c x a -> Parser.Advanced.Parser c x ()"}],"binops":[]},{"name":"Parser.Extra","comment":" Convenience functions for\n[`Parser`](https://package.elm-lang.org/packages/elm/parser/latest/Parser).\n\n\n## Table of Contents\n\n  - [Look Ahead](#look-ahead)\n  - [Miscellaneous](#miscellaneous)\n  - [Binds](#binds)\n  - [Low-Level](#low-level)\n\n\n# Look Ahead\n\n@docs lookAhead, negativeLookAhead\n\n\n# Miscellaneous\n\n@docs followedBy, committed\n\n\n# Binds\n\nFlipped versions of [`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#andThen)\nwith 1 to 5 parsers and callbacks with 1 to 5 input parameters.\n\n(In other functional languages, the flipped\nversion of `andThen` is often called \"bind\",\nhence the names here.)\n\n@docs bind, bind2, bind3, bind4, bind5\n\n\n# Low-Level\n\nThese are low-level functions which are used under the hood to implement\nsome of the other parsers of this module.\n\nMaybe they can be useful to you, too?\n\n@docs ParserResult, getParserResult, getParserOutcome\n\n","unions":[],"aliases":[{"name":"ParserResult","comment":" Result of [`Parser.run`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#run).\nThe type alias simplifies the following function signatures a little bit.\n","args":["a"],"type":"Result.Result (List.List Parser.DeadEnd) a"}],"values":[{"name":"bind","comment":" Flipped version of [`andThen`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#andThen).\n\nIf you use `andThen` without the forward pipe operator,\nthis can save some parentheses and an extra level of indenting.\n\n    andThen:\n\n        parser\n            |> andThen\n                (\\value ->\n                    ...\n                )\n\n    bind:\n\n        bind parser <|\n            \\value ->\n                ...\n\n","type":"Parser.Parser a -> (a -> Parser.Parser b) -> Parser.Parser b"},{"name":"bind2","comment":" Runs the 2 parsers one after the other and then calls the callback\nfunction with the 2 parsed values.\n\nStops at the first failure.\n\nThis can be handy if you need to independently parse 2 values and then\nprocess them together. It reduces the indentation of the code:\n\n    andThen:\n\n        getSource\n            |> andThen\n                (\\source ->\n                    getOffset\n                        |> andThen\n                            (\\offset ->\n                                ...\n                            )\n                )\n\n    bind:\n\n        bind getSource <|\n            \\source ->\n                bind getOffset <|\n                    \\offset ->\n                        ...\n\n    bind2:\n\n        bind2 getSource getOffset <|\n            \\source offset ->\n                ...\n\n","type":"Parser.Parser a1 -> Parser.Parser a2 -> (a1 -> a2 -> Parser.Parser b) -> Parser.Parser b"},{"name":"bind3","comment":" Runs the 3 parsers one after the other and then calls the callback\nfunction with the 3 parsed values.\n\nStops at the first failure.\n\nThis can be handy if you need to independently parse 3 values and then\nprocess them together. It reduces the indentation of the code.\nFor an example with 2 parsers see [`bind2`](#bind2).\n\n","type":"Parser.Parser a1 -> Parser.Parser a2 -> Parser.Parser a3 -> (a1 -> a2 -> a3 -> Parser.Parser b) -> Parser.Parser b"},{"name":"bind4","comment":" Runs the 4 parsers one after the other and then calls the callback\nfunction with the 4 parsed values.\n\nStops at the first failure.\n\nThis can be handy if you need to independently parse 4 values and then\nprocess them together. It reduces the indentation of the code.\nFor an example with 2 parsers see [`bind2`](#bind2).\n\n","type":"Parser.Parser a1 -> Parser.Parser a2 -> Parser.Parser a3 -> Parser.Parser a4 -> (a1 -> a2 -> a3 -> a4 -> Parser.Parser b) -> Parser.Parser b"},{"name":"bind5","comment":" Runs the 5 parsers one after the other and then calls the callback\nfunction with the 5 parsed values.\n\nStops at the first failure.\n\nThis can be handy if you need to independently parse 5 values and then\nprocess them together. It reduces the indentation of the code.\nFor an example with 2 parsers see [`bind2`](#bind2).\n\n","type":"Parser.Parser a1 -> Parser.Parser a2 -> Parser.Parser a3 -> Parser.Parser a4 -> Parser.Parser a5 -> (a1 -> a2 -> a3 -> a4 -> a5 -> Parser.Parser b) -> Parser.Parser b"},{"name":"committed","comment":" The opposite of [`backtrackable`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#backtrackable).\nThe parser is made _not_ backtrackable, a.k.a. \"committed\".\n\nIt's implemented as:\n\n    committed : Parser a -> Parser a\n    committed parser =\n        Parser.commit ()\n            |> followedBy parser\n\n","type":"Parser.Parser a -> Parser.Parser a"},{"name":"followedBy","comment":" Executes two parsers in sequence, discarding the first result.\n\nNote that the arguments are flipped to make the function easily\nusable with the forward pipe operator:\n\n    import Parser exposing (Parser)\n\n    testParser : Parser Int\n    testParser =\n        Parser.token \"> \"\n            |> followedBy Parser.int\n\n    Parser.run testParser \"> 123\"\n    --> Ok 123\n\n","type":"Parser.Parser b -> Parser.Parser a -> Parser.Parser b"},{"name":"getParserOutcome","comment":" An enhanced version of [`getParserResult`](#getParserResult).\nIt additionally gets:\n\n  - the remaining source string (the source string starting at the current parser position)\n  - the offset where the given parser stopped, relative to the beginning of the\n    remaining source string (if the given parser succeeded)\n\nThe following example shows all these values:\n\n    import Parser exposing ((|.), (|=), Parser)\n\n    originalParser : Parser Int\n    originalParser =\n        Parser.int\n\n    outcomeParser : Parser ( String, ParserResult ( Int, Int ) )\n    outcomeParser =\n        getParserOutcome originalParser\n\nThe `outcomeParser` performs a test run of the `originalParser`\nand then yields the results of the test run as described above.\n\n    sampleParser : Parser ( String, ParserResult ( Int, Int ) )\n    sampleParser =\n        Parser.token \"hello \"\n            |> followedBy outcomeParser\n\nThe `sampleParser` first chomps the string \"hello \"\n(so that the current parser position is not at the beginning)\nand then calls the `outcomeParser`\n(using this package's function [`followedBy`](#followedBy)).\n\nThe results when the `originalParser` succeeds:\n\n    Parser.run sampleParser \"hello 123 world\"\n    --> Ok ( \"123 world\", Ok ( 123, 3 ))\n\n  - the remaining source string after the initial \"hello \" is \"123 world\"\n  - the result of the `originalParser` is 123\n  - the position after the `originalParser` is run is 3\n    (relative to the beginning of the remaining source string)\n    which means that the `originalParser` has chomped 3 characters\n\nThe results when the `originalParser` fails:\n\n    Parser.run sampleParser \"hello world\"\n    --> Ok\n    -->   ( \"world\"\n    -->   , Err\n    -->       [ { row = 1\n    -->         , col = 1\n    -->         , problem = Parser.ExpectingInt\n    -->         }\n    -->       ]\n    -->   )\n\n  - the remaining source string after the initial \"hello \" is \"world\"\n  - the error of the `originalParser`\n\nNote that the error position is relative to the beginning of the remaining source string, too.\n\n","type":"Parser.Parser a -> Parser.Parser ( String.String, Parser.Extra.ParserResult ( a, Basics.Int ) )"},{"name":"getParserResult","comment":" Gets the result of running the given parser at the current position.\n\n**Note:** the test run has absolutely **no effect** on the current parser state!\n\nThis could be used to implement a [`lookAhead`](#lookAhead) parser on your own\n(in fact, this _is_ the real implementation):\n\n    import Parser exposing ((|=), Parser)\n\n    myLookAhead : Parser a -> Parser a\n    myLookAhead parser =\n        bind (getParserResult parser) <|\n            \\result ->\n                case result of\n                    Ok a ->\n                        Parser.succeed a\n                    Err _ ->\n                        -- here we know that the parser\n                        -- fails with the expected error\n                        -- but we want it backtrackable\n                        Parser.backtrackable parser\n\n    lookAheadParser : Parser Int\n    lookAheadParser =\n        myLookAhead Parser.int\n\n    sampleParser : Parser ( Int, String )\n    sampleParser =\n        Parser.succeed Tuple.pair\n            |= lookAheadParser\n            |= Parser.getChompedString lookAheadParser\n\n    Parser.run sampleParser \"123abc\"\n    --> Ok ( 123, \"\" )\n\nThe `sampleParser` calls the `lookAheadParser` twice:\n\n  - once to get the parsed value\n  - once to get the chomped string\n\nAs expected, the parsed value is returned _without_ chomping any characters.\n\n","type":"Parser.Parser a -> Parser.Parser (Parser.Extra.ParserResult a)"},{"name":"lookAhead","comment":" A parser that succeeds if the given parser succeeds at the current position\nand fails otherwise. The difference to using the original parser is that this\nparser doesn't chomp any characters and is always backtrackable.\n\nLookahead assertions are also known from regular expressions.\n\nIn the following example, we create a lookAhead parser from a\n[`Parser.token`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#token):\n\n    import Parser exposing (Parser)\n\n    originalParser : Parser ()\n    originalParser =\n        Parser.token \"hello\"\n\n    lookAheadParser : Parser ()\n    lookAheadParser =\n        lookAhead originalParser\n\nHere's how the parsers behave in the success and in the failure case:\n\n    Parser.run originalParser \"hello world\"\n    --> Ok ()\n\n    Parser.run lookAheadParser \"hello world\"\n    --> Ok ()\n\n    Parser.run originalParser \"hi world\"\n    --> Err\n    -->   [ { row = 1\n    -->     , col = 1\n    -->     , problem = Parser.Expecting \"hello\"\n    -->     }\n    -->   ]\n\n    Parser.run lookAheadParser \"hi world\"\n    --> Err\n    -->   [ { row = 1\n    -->     , col = 1\n    -->     , problem = Parser.Expecting \"hello\"\n    -->     }\n    -->   ]\n\nIf the original parser succeeds, the lookAhead parser succeeds too,\nand if the original parser fails, so does the lookAhead parser.\n\nIt seems that both are doing the same.\nThe difference is that the lookAhead parser doesn't chomp any characters:\n\n    Parser.run (Parser.getChompedString originalParser)\n        \"hello world\"\n    --> Ok \"hello\"\n\n    Parser.run (Parser.getChompedString lookAheadParser)\n        \"hello world\"\n    --> Ok \"\"\n\n","type":"Parser.Parser a -> Parser.Parser a"},{"name":"negativeLookAhead","comment":" A parser that succeeds if the given parser fails at the current position\nand fails with the given problem message otherwise.\nThis parser doesn't chomp any characters and is always backtrackable.\n\nNegative lookahead assertions are also known from regular expressions.\n\nIn the following example, we create a negativeLookAhead parser from a\n[`Parser.int`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#int):\n\n    import Parser exposing (Parser)\n\n    originalParser : Parser Int\n    originalParser =\n        Parser.int\n\n    negativeLookAheadParser : Parser ()\n    negativeLookAheadParser =\n        negativeLookAhead \"unexpected int\" originalParser\n\nHere's how the parsers behave in the success and in the failure case:\n\n    Parser.run originalParser \"123abc\"\n    --> Ok 123\n\n    Parser.run negativeLookAheadParser \"123abc\"\n    --> Err\n    -->   [ { row = 1\n    -->     , col = 1\n    -->     , problem = Parser.Problem \"unexpected int\"\n    -->     }\n    -->   ]\n\n    Parser.run originalParser \"abc123\"\n    --> Err\n    -->   [ { row = 1\n    -->     , col = 1\n    -->     , problem = Parser.ExpectingInt\n    -->     }\n    -->   ]\n\n    Parser.run negativeLookAheadParser \"abc123\"\n    --> Ok ()\n\nIf the original parser succeeds, the negativeLookAhead parser fails,\nand if the original parser fails, the negativeLookAhead parser succeeds.\n\n","type":"String.String -> Parser.Parser a -> Parser.Parser ()"}],"binops":[]}]